<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Chussy Inferno 3D</title>
    <style>
        body { 
            margin: 0; 
            background: #000;
            overflow: hidden;
            touch-action: none;
        }
        canvas { 
            width: 100vw;
            height: 100vh;
        }
        .game-title {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            text-align: center;
            color: #ff4400;
            font-size: 48px;
            font-family: 'Comic Sans MS', cursive;
            text-shadow: 0 0 10px #ff0000;
            z-index: 2;
            background: rgba(0,0,0,0.8);
            padding: 10px;
        }
        .flame-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .flame {
            position: absolute;
            font-size: 24px;
            animation: fall linear infinite;
        }
        @keyframes fall {
            from { transform: translateY(-20px); }
            to { transform: translateY(100vh); }
        }
        .mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 10px;
            z-index: 1000;
        }
        .mobile-controls button {
            width: 60px;
            height: 60px;
            background: rgba(255,68,0,0.5);
            border: 2px solid #ff4400;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            touch-action: none;
        }
        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
            }
        }
        .ceo-approval {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 2;
            text-align: center;
            color: #ff4400;
            text-shadow: 0 0 10px #ff0000;
        }
        .ceo-approval img {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 2px solid #ff4400;
            box-shadow: 0 0 10px #ff0000;
        }
        .tos-link {
            position: fixed;
            bottom: 10px;
            right: 10px;
            color: #ff4400;
            text-decoration: none;
            font-family: 'Comic Sans MS', cursive;
            text-shadow: 0 0 5px #ff0000;
            z-index: 2;
        }
    </style>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-YOURPUBID"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <h1 class="game-title">üî• SUSSY INFERNO 3D üî•</h1>
    <div class="flame-container" id="flameContainer"></div>
    <canvas id="gameCanvas"></canvas>
    <div class="mobile-controls">
        <button id="leftBtn">‚Üê</button>
        <button id="upBtn">‚Üë</button>
        <button id="downBtn">‚Üì</button>
        <button id="rightBtn">‚Üí</button>
        <button id="shootBtn">üßÄ</button>
    </div>
    <div class="ceo-approval">
        <p>ThePrimeagen Approves of this webpage</p>
        <img src="https://avatars.githubusercontent.com/u/4442245" alt="ThePrimeagen CEO">
    </div>
    <a href="termsofservice.html" class="tos-link">Sussy Terms of Service</a>
    <!-- IE Compatibility polyfills -->
    <script>
        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = function(callback) {
                return setTimeout(callback, 1000 / 60);
            };
        }
        if (!Array.prototype.forEach) {
            Array.prototype.forEach = function(callback) {
                for (var i = 0; i < this.length; i++) {
                    callback(this[i], i, this);
                }
            };
        }
    </script>
    <script>
        // Auto-refresh
        let lastActivity = Date.now();
        document.addEventListener('mousemove', () => lastActivity = Date.now());
        document.addEventListener('keydown', () => lastActivity = Date.now());
        document.addEventListener('click', () => lastActivity = Date.now());
        setInterval(() => {
            if (Date.now() - lastActivity > 60000) {
                window.location.reload();
            }
        }, 10000);

        // Flame emojis
        function createFlame() {
            const flame = document.createElement('div');
            flame.className = 'flame';
            flame.textContent = 'üî•';
            flame.style.left = Math.random() * 100 + 'vw';
            flame.style.animationDuration = Math.random() * 3 + 2 + 's';
            document.getElementById('flameContainer').appendChild(flame);
            flame.addEventListener('animationend', () => flame.remove());
        }
        setInterval(createFlame, 500);

        // Game state
        const state = {
            projectiles: [],
            enemies: [],
            autoplay: false,
            lastInputTime: Date.now(),
            keys: {
                w: false,
                s: false,
                a: false,
                d: false,
                space: false
            }
        };

        // Map data and textures
        const WALL_TEXTURES = [
            'https://placekitten.com/64/64',
            'https://placekitten.com/65/65',
            'https://placekitten.com/66/66'
        ];
        const ENEMY_SPRITES = [
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAKUSURBVFiF7ZdNaBNBFMd/s9mkTWqSJk1JW7QqVkWkKB5E/LiIBz0IHhQP4smDFBE96NGDiCBeRPCgICIePCh4EDyJKCLiQaqCn1Vr1TaxX2natGmbNLvjYZNQapKNwYvgf9h9M/P+v5n3ZnYXYmJiYmJi/jFCVJGxgQutLqt1QEF0KKDVg9MBhgaGBgt+0F0Q8MHrg4U5WJiHOQ/4QqJnGXwB8C/7cblcRQKaptWsr6tpQwfg9kDfEehsg+5OaG8Fu6263vRnmPLAu0/w8j28eAsTn8DnD4VFUcxqmhbUdd0kSZJRIVAUBYfDEVHsdMDxI3DyGBzYA4oSWby1GY7sgxMDkJmHp6/h0XOYmQNVVc2qqpbVxWAwGNzc3KxrmsZGxe6dMD4Kj27A+cHw4rXY2QaXhmFqAq4OQ0dbKLZly5b1/0QgEMDpdEYU7+2Gx7fg7jXY01V//M52uH8dHt6E/T3rx202W1ldVVUxm81/JGDRYP8eePcE7l2HzraNz7OrA+5ehwf5cPZQyJvNZkRRLBNQFAWLxVJ3YLMZTh+HyXG4NQItTRvPvxaXE26PwtvHcG4QrFYriqKU1SVJQpblugI2K1wcgk9P4MoFaLJvbvHvabLDtQswPQ6XhsFmtSLLMoqilAkEg0Hs9sgXpd0Gly/A7DhcPgeODSxc9/PrAq4Mw+cJuDgEDrsNWZYJBoNldUmSEASh7gQAkoNw/Qh8fR7e5/U2YiP6jXDqIPyYhLPHQRAEJEkqq5tMJrxeL4ZhRJ6gqRFujMBMBvp6N79wbxdkH8KFDDA0UPf5EEURn8+HYRhlAoqiYLVasVgsUcVNDZAIL7jxb0IQBERRxOfzoes6APJvjT9e8/8RQRBQVZVAIABALBATExMT8z/zC1vqIVMI2EIJAAAAAElFTkSuQmCC',
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAKUSURBVFiF7ZdNaBNBFMd/s9mkTWqSJk1JW7QqVkWkKB5E/LiIBz0IHhQP4smDFBE96NGDiCBeRPCgICIePCh4EDyJKCLiQaqCn1Vr1TaxX2natGmbNLvjYZNQapKNwYvgf9h9M/P+v5n3ZnYXYmJiYmJi/jFCVJGxgQutLqt1QEF0KKDVg9MBhgaGBgt+0F0Q8MHrg4U5WJiHOQ/4QqJnGXwB8C/7cblcRQKaptWsr6tpQwfg9kDfEehsg+5OaG8Fu6263vRnmPLAu0/w8j28eAsTn8DnD4VFUcxqmhbUdd0kSZJRIVAUBYfDEVHsdMDxI3DyGBzYA4oSWby1GY7sgxMDkJmHp6/h0XOYmQNVVc2qqpbVxWAwGNzc3KxrmsZGxe6dMD4Kj27A+cHw4rXY2QaXhmFqAq4OQ0dbKLZly5b1/0QgEMDpdEYU7+2Gx7fg7jXY01V//M52uH8dHt6E/T3rx202W1ldVVUxm81/JGDRYP8eePcE7l2HzraNz7OrA+5ehwf5cPZQyJvNZkRRLBNQFAWLxVJ3YLMZTh+HyXG4NQItTRvPvxaXE26PwtvHcG4QrFYriqKU1SVJQpblugI2K1wcgk9P4MoFaLJvbvHvabLDtQswPQ6XhsFmtSLLMoqilAkEg0Hs9sgXpd0Gly/A7DhcPgeODSxc9/PrAq4Mw+cJuDgEDrsNWZYJBoNldUmSEASh7gQAkoNw/Qh8fR7e5/U2YiP6jXDqIPyYhLPHQRAEJEkqq5tMJrxeL4ZhRJ6gqRFujMBMBvp6N79wbxdkH8KFDDA0UPf5EEURn8+HYRhlAoqiYLVasVgsUcVNDZAIL7jxb0IQBERRxOfzoes6APJvjT9e8/8RQRBQVZVAIABALBATExMT8z/zC1vqIVMI2EIJAAAAAElFTkSuQmCC'
        ];
        const CHEESE_SPRITE = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAGUlEQVQYV2P8z8Dwn4EAYBxVQEgBNs0gDQBn4gQJE+ZTogAAAABJRU5ErkJggg==';

        const textureImages = WALL_TEXTURES.map(url => {
            const img = new Image();
            img.src = url;
            return img;
        });

        const enemyImages = ENEMY_SPRITES.map(url => {
            const img = new Image();
            img.src = url;
            return img;
        });

        // Map data with different wall types
        const MAP = [
            [1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,1],
            [1,0,2,0,0,3,0,1],
            [1,0,0,0,0,0,0,1],
            [1,0,3,0,0,2,0,1],
            [1,0,0,0,0,0,0,1],
            [1,0,2,0,0,3,0,1],
            [1,1,1,1,1,1,1,1]
        ];

        // Player state
        const player = {
            x: 1.5,
            y: 1.5,
            angle: 0,
            fov: Math.PI / 2.5,  // Wider field of view
            speed: 0.15,
            turnSpeed: 0.12,
            health: 100,
            maxHealth: 100
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Raycasting
        function castRay(rayAngle) {
            let rayX = player.x;
            let rayY = player.y;
            let rayDirX = Math.cos(rayAngle);
            let rayDirY = Math.sin(rayAngle);
            
            let distance = 0;
            while (distance < 20) {
                rayX += rayDirX * 0.1;
                rayY += rayDirY * 0.1;
                distance += 0.1;
                
                let mapX = Math.floor(rayX);
                let mapY = Math.floor(rayY);
                
                if (MAP[mapY] && MAP[mapY][mapX] > 0) {
                    const wallType = MAP[mapY][mapX];
                    const textureX = Math.floor((rayX % 1) * textureImages[wallType-1].width);
                    return { distance, wallType, textureX };
                }
            }
            return { distance: 20, wallType: 0, textureX: 0 };
        }

        function updatePlayerMovement() {
            let dx = 0;
            let dy = 0;
            
            if (state.keys.w) {
                dx += Math.cos(player.angle) * player.speed;
                dy += Math.sin(player.angle) * player.speed;
            }
            if (state.keys.s) {
                dx -= Math.cos(player.angle) * player.speed;
                dy -= Math.sin(player.angle) * player.speed;
            }
            if (state.keys.a) {
                player.angle -= player.turnSpeed;
            }
            if (state.keys.d) {
                player.angle += player.turnSpeed;
            }
            
            // Normalize diagonal movement
            if (dx !== 0 && dy !== 0) {
                const length = Math.sqrt(dx * dx + dy * dy);
                dx = (dx / length) * player.speed;
                dy = (dy / length) * player.speed;
            }
            
            const newX = player.x + dx;
            const newY = player.y + dy;
            
            if (!checkCollision(newX, newY)) {
                player.x = newX;
                player.y = newY;
            }
        }

        function drawFrame() {
            updatePlayerMovement();
            // Clear screen with dark gradient for atmosphere
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#000');
            gradient.addColorStop(1, '#111');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Optimize raycasting
            const numRays = Math.floor(canvas.width / 2); // Reduced for better performance
            const rayStep = player.fov / numRays;
            
            for (let i = 0; i < numRays; i++) {
                const rayAngle = player.angle - player.fov/2 + rayStep * i;
                const distance = castRay(rayAngle);
                const wallHeight = canvas.height / distance;
                
                ctx.fillStyle = `rgb(${255/distance}, ${255/distance}, ${255/distance})`;
                ctx.fillRect(i, (canvas.height-wallHeight)/2, 1, wallHeight);
            }
            
            requestAnimationFrame(drawFrame);
        }

        // Input handling
        function checkCollision(x, y) {
            const mapX = Math.floor(x);
            const mapY = Math.floor(y);
            const buffer = 0.2; // Collision buffer
            
            if (MAP[mapY] && MAP[mapY][mapX] > 0) return true;
            
            // Check corners for smoother collision
            const corners = [
                { x: x + buffer, y: y + buffer },
                { x: x - buffer, y: y + buffer },
                { x: x + buffer, y: y - buffer },
                { x: x - buffer, y: y - buffer }
            ];
            
            return corners.some(corner => {
                const cornerMapX = Math.floor(corner.x);
                const cornerMapY = Math.floor(corner.y);
                return MAP[cornerMapY] && MAP[cornerMapY][cornerMapX] > 0;
            });
        }

        function updatePlayerMovement() {
            let dx = 0;
            let dy = 0;
            
            if (state.keys.w) {
                dx += Math.cos(player.angle) * player.speed;
                dy += Math.sin(player.angle) * player.speed;
            }
            if (state.keys.s) {
                dx -= Math.cos(player.angle) * player.speed;
                dy -= Math.sin(player.angle) * player.speed;
            }
            if (state.keys.a) {
                player.angle -= player.turnSpeed;
            }
            if (state.keys.d) {
                player.angle += player.turnSpeed;
            }
            
            // Normalize diagonal movement
            if (dx !== 0 && dy !== 0) {
                const length = Math.sqrt(dx * dx + dy * dy);
                dx = (dx / length) * player.speed;
                dy = (dy / length) * player.speed;
            }
            
            const newX = player.x + dx;
            const newY = player.y + dy;
            
            if (!checkCollision(newX, newY)) {
                player.x = newX;
                player.y = newY;
            }
        }

        function handleInput(e) {
            if (e.key === ' ') {
                state.projectiles.push({
                    x: player.x,
                    y: player.y,
                    angle: player.angle,
                    speed: 0.5,
                    damage: 50
                });
            }
        }

        // Mobile controls
        function setupMobileControls() {
            const buttons = {
                leftBtn: { key: 'a' },
                rightBtn: { key: 'd' },
                upBtn: { key: 'w' },
                downBtn: { key: 's' },
                shootBtn: { key: ' ' }
            };

            Object.entries(buttons).forEach(([id, { key }]) => {
                const btn = document.getElementById(id);
                
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    state.keys[key] = true;
                    state.lastInputTime = Date.now();
                });

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    state.keys[key] = false;
                });
            });
        }

        document.addEventListener('keydown', (e) => {
            if (e.key in state.keys) {
                state.keys[e.key] = true;
                state.lastInputTime = Date.now();
            }
            handleInput(e);
        });

        document.addEventListener('keyup', (e) => {
            if (e.key in state.keys) {
                state.keys[e.key] = false;
            }
        });

        setupMobileControls();

        // Autoplay feature
        function updateAutoplay() {
            if (!state.autoplay) {
                if (Date.now() - state.lastInputTime > 30000) {
                    state.autoplay = true;
                }
                return;
            }

            // Find closest enemy
            let closestEnemy = null;
            let closestDist = Infinity;
            
            state.enemies.forEach(enemy => {
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestEnemy = enemy;
                }
            });

            if (closestEnemy) {
                // Calculate angle to enemy
                const dx = closestEnemy.x - player.x;
                const dy = closestEnemy.y - player.y;
                const targetAngle = Math.atan2(dy, dx);
                
                // Turn towards enemy
                const angleDiff = (targetAngle - player.angle + Math.PI * 3) % (Math.PI * 2) - Math.PI;
                if (angleDiff > 0.1) {
                    player.angle += player.turnSpeed;
                } else if (angleDiff < -0.1) {
                    player.angle -= player.turnSpeed;
                }

                // Move towards enemy if too far, away if too close
                if (closestDist > 3) {
                    player.x += Math.cos(player.angle) * player.speed;
                    player.y += Math.sin(player.angle) * player.speed;
                } else if (closestDist < 2) {
                    player.x -= Math.cos(player.angle) * player.speed;
                    player.y -= Math.sin(player.angle) * player.speed;
                }

                // Shoot if facing enemy
                if (Math.abs(angleDiff) < 0.2) {
                    state.projectiles.push({
                        x: player.x,
                        y: player.y,
                        angle: player.angle,
                        speed: 0.5,
                        damage: 50
                    });
                }
            }
        }

        // Reset autoplay on user input
        document.addEventListener('keydown', () => {
            state.lastInputTime = Date.now();
            state.autoplay = false;
        });
        document.addEventListener('mousemove', () => {
            state.lastInputTime = Date.now();
            state.autoplay = false;
        });

        function drawFrame() {
            updatePlayerMovement();
            updateAutoplay();
            
            // Clear screen with dark gradient for atmosphere
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#000');
            gradient.addColorStop(1, '#111');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw floor
            const floorGradient = ctx.createLinearGradient(0, canvas.height/2, 0, canvas.height);
            floorGradient.addColorStop(0, '#222');
            floorGradient.addColorStop(1, '#111');
            ctx.fillStyle = floorGradient;
            ctx.fillRect(0, canvas.height/2, canvas.width, canvas.height/2);
            
            // Optimize raycasting
            const numRays = Math.floor(canvas.width / 2);
            const rayStep = player.fov / numRays;
            
            for (let i = 0; i < numRays; i++) {
                const rayAngle = player.angle - player.fov/2 + rayStep * i;
                const { distance, wallType, textureX } = castRay(rayAngle);
                const wallHeight = canvas.height / distance;
                
                if (wallType > 0) {
                    const texture = textureImages[wallType-1];
                    if (texture.complete) {
                        ctx.drawImage(
                            texture,
                            textureX, 0, 1, texture.height,
                            i*2, (canvas.height-wallHeight)/2, 2, wallHeight
                        );
                    }
                }
            }
            
            // Draw projectiles
            ctx.fillStyle = '#ff0';
            state.projectiles.forEach(proj => {
                const screenX = (proj.x - player.x) * 50 + canvas.width/2;
                const screenY = (proj.y - player.y) * 50 + canvas.height/2;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 5, 0, Math.PI * 2);
                ctx.fill();
            });
            
            requestAnimationFrame(drawFrame);
        }

        drawFrame();
    </script>
</body>
</html>
